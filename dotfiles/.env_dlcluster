getnode() {
  local partition="L40x4";
  local duration="8:00:00";
  while [[ $# -gt 0 ]]; do
    case $1 in
      -t|--time)
        shift;
        duration="$1";
        shift;
        ;;
      *)
        partition="$1";
        break;
        ;;
    esac
  done;
  if [[ ${partition} == "viking" ]]; then
    partition="viking-prod -A viking";
  fi;
  srun -t ${duration} -p ${partition} --pty bash;
}

runcontainer() {
  local __descr="
runcontainer: General purpose container runner that can handle both image URLs and composable
              services defined in a docker-compose YAML file. Standard Docker options will be
              passed to the docker executable when launching images, but they will not be passed to
              'docker compose run' when launching composable services. In both cases, the container
              will launch with a local user that mirrors the host user's UID, GID and LOGIN to
              help avoid breaking file ownership/permissions. However, this local user will also
              have passwordless 'sudo' privileges to facilitate free modification of the container.
";
    local __usage="
Usage: runcontainer [OPTIONS] [DOCKER_OPTIONS] <IMAGE|SERVICE>

Options:
  -h, --help                    Display this help message.
  -f, --file[=]                 Path to the docker-compose YAML file.
      --dotfiles[=]             Path to the host user's dotfiles (e.g. .bashrc), to be mounted to
                                the container user's home directory when launching images.
                                Composable services will only mount volumes defined in the docker
                                compose YAML.

Always-on Docker Options:
  -i, --interactive             Keep STDIN open even if not attached.
  -t, --tty                     Allocate a pseudo-TTY.
      --privileged              Run with extended privileges.
      --network=host            Use the host machine's network.
      --ipc=host                Use the host machine's IPC mode.
      --ulimit memlock=-1       Set maximum locked-in memory address space.
      --ulimit stack=67108864   Set stack size.
";
  if [[ $# -eq 0 ]]; then
    printf "runcontainer: ERROR: Missing image URL or composable service name.";
    printf "$__usage";
    return 1;
  fi;

  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    printf "$__descr";
    printf "$__usage";
    return 0;
  fi;

  # parse docker compose arguments
  local DETACH="";
  local CONTAINER="${*: -1}";
  local COMPOSE_FILE="${HOME}/.config/containers/docker-compose.yaml";
  local new_compose_file=false;
  local unused_compose_args=();
  local get_next=false;
  for arg in "$@"; do
    if $get_next; then
      COMPOSE_FILE="$arg";
      get_next=false;
    elif [[ "$arg" == "--file="* ]]; then
      COMPOSE_FILE=$(cut -d'=' -f2 <<< "$arg");
      new_compose_file=true;
    elif [[ "$arg" == "-f" || "$arg" == "--file" ]]; then
      get_next=true;
      new_compose_file=true;
    elif [[ "$arg" == "-d" || "$arg" == "--detach" ]]; then
      DETACH="$arg ";
    elif [[ "$arg" != "${CONTAINER}" && "$arg" != "$0" ]]; then
      unused_compose_args=( "$arg" );
    fi;
  done;

  # check if the given container is a composable service
  local is_composable=false;
  if [[ -f "${COMPOSE_FILE}" ]]; then
    local found_services=false;
    while read -r line || [[ -n $line ]]; do
      trimmed=$(echo $line | tr -d : | tr -d '[:blank:]');
      if [[ $trimmed == "services" ]]; then
        found_services=true;
      elif $found_services && [[ $trimmed = "${CONTAINER}" ]]; then
        is_composable=true;
        break;
      fi;
    done < $COMPOSE_FILE;
  else
    printf "runcontainer: ERROR: Invalid path for docker compose YAML file (${COMPOSE_FILE}).";
    printf "$__usage";
    return 1;
  fi;

  if $is_composable; then
    # given container is a docker compose service
    if [[ ${#unused_compose_args[@]} -gt 0 ]]; then
      printf "runcontainer: WARNING: Cannot use Docker options (${unused_compose_args[*]}) with composable services.";
    fi
    # update UID/GID in the docker compose services
    sed -i "s/user:.*/user: $(id -u):$(id -g)/" $COMPOSE_FILE;
    # # build the composed container
    # local build_cmd="docker compose -f ${COMPOSE_FILE} build --no-cache ${CONTAINER}"
    # printf "runcontainer: BUILDING: ${build_cmd}"
    # $build_cmd
    # launch the composed container
    local start_cmd="docker compose -f ${COMPOSE_FILE} up --build ${DETACH}${CONTAINER}";
    printf "runcontainer: STARTING: ${start_cmd}\n";
    $start_cmd;
  else
    # if we got here but user passed in a compose file path, that probably mean user intended to run
    # a composable service that does not exist in the file
    if $new_compose_file; then
      printf "runcontainer: ERROR: Docker compose YAML file (${COMPOSE_FILE}) does not contain ${CONTAINER} service.";
      printf "$__usage";
      return 1;
    fi;

    # given container is an image so we need to parse user arguments (if any)
    local NETWORK="host";
    local IPC="host";
    local ULIMIT_MEMLOCK=-1;
    local ULIMIT_STACK=67108864;
    local ENTRYPOINT="${HOME}/.config/containers/entrypoint.sh";
    local USER_MOUNTS=();
    local USER_ARGS=();
    while [[ $# -gt 1 ]]; do
      case "$1" in
        --network*)
          if [[ "$1" == *"="* ]]; then
            NETWORK=$(cut -d'=' -f2 <<< "$1");
          else
            shift; NETWORK="$1";
          fi;
          shift;
          ;;
        --ipc*)
          if [[ "$1" == *"="* ]]; then
            IPC=$(cut -d'=' -f2 <<< "$1");
          else
            shift; IPC="$1";
          fi;
          shift;
          ;;
        --ulimit)
          shift;
          case "$1" in
            memlock=*)
              ULIMIT_MEMLOCK=$(cut -d'=' -f2 <<< "$1");
              ;;
            stack=*)
              ULIMIT_STACK=$(cut -d'=' -f2 <<< "$1");
              ;;
            *)
              USER_ARGS+=( "--ulimit" "$1" );
              ;;
          esac;
          shift;
          ;;
        -v|--volume=*)
          if [[ "$1" == *"="* ]]; then
            tmp=$(cut -d'=' -f2 <<< "$1");
          else
            shift; tmp="$1";
          fi;
          USER_MOUNTS+=( "${tmp}" );
          shift;
          ;;
        --stash*)
          if [[ "$1" == *"="* ]]; then
            STASH=$(cut -d'=' -f2 <<< "$1");
          else
            shift; STASH="$1";
          fi;
          shift;
          ;;
        --entrypoint*)
          if [[ "$1" == *"="* ]]; then
            ENTRYPOINT=$(cut -d'=' -f2 <<< "$1");
          else
            shift; ENTRYPOINT="$1";
          fi;
          shift;
          ;;
        -f|--file*|-e|--env)
          # we've already parsed these before
          shift;
          if [[ "$1" != *"="* ]]; then
            # arguments with space-sperated values need an extra shift
            shift;
          fi;
          ;;
        -i|--interactive|-t|--tty|-it|--privileged|--rm|--verbose)
          # ignore these user options because we are using them anyway
          shift;
          ;;
        *)
          USER_ARGS+=( "$1" );
          shift;
          ;;
      esac;
      shift;
    done;

    # update UID/GID in the entrypoint script
    sed -i "s/HOST_USER=.*/HOST_USER=$(whoami)/" $ENTRYPOINT;
    sed -i "s/HOST_UID=.*/HOST_UID=$(id -u)/" $ENTRYPOINT;
    sed -i "s/HOST_GROUP=.*/HOST_GROUP=$(groups | cut -d' ' -f1)/" $ENTRYPOINT;
    sed -i "s/HOST_GID=.*/HOST_GID=$(id -g)/" $ENTRYPOINT;

    # construct default arguments and launch container
    local BASE_ARGS=(
      "--gpus all"
      "--runtime nvidia"
      "--interactive"
      "--tty"
      "--privileged"
      "--network=${NETWORK}"
      "--ipc=${IPC}"
      "--shm-size=1g"
      "--ulimit memlock=${ULIMIT_MEMLOCK}"
      "--ulimit stack=${ULIMIT_STACK}"
      "--entrypoint=/root/entrypoint.sh"
    );

    # list of default volumes to mount
    [ -e "/tmp/${USER}_docker_entrypoint.sh" ] && rm "/tmp/${USER}_docker_entrypoint.sh";
    cp "${ENTRYPOINT}" "/tmp/${USER}_docker_entrypoints.sh";
    chmod 755 "/tmp/${USER}_docker_entrypoint.sh";
    local MOUNT_POINTS=(
      "/raid:/raid"
      "${DEVROOT}:${DEVROOT}"
      "${HOME}:${HOME}"
      "/tmp/${USER}_docker_entrypoints.sh:/root/entrypoint.sh"
    );

    # add user-specified mount points to the volumes list, without duplicates
    for item in "${USER_MOUNTS[@]}"; do
      if [[ "${MOUNT_POINTS[*]}" != *"${item}"* ]]; then
        MOUNT_POINTS+=( "${item}" );
      fi;
    done;

    # if there's an ssh agent running, mount the socket for container to inherit
    if [[ -n "${SSH_AUTH_SOCK}" ]]; then
      MOUNT_POINTS+=( "${SSH_AUTH_SOCK}:/ssh-agent" );
      BASE_ARGS+=( "--env SSH_AUTH_SOCK='/ssh-agent'" );
    fi;

    # contruct the volumes argument string with -v in front of each mount point
    local VOLUMES=$(printf -- '--volume %s ' "${MOUNT_POINTS[@]}" | xargs);

    local nvidia_cmd="docker run ${VOLUMES} ${BASE_ARGS[*]} ${USER_ARGS[*]} ${CONTAINER} /bin/bash";
    printf "runcontainer: COMMAND: $(echo "$nvidia_cmd" | sed -E "s|--|\\n    --|g" | sed -E "s|$CONTAINER|\\n    $CONTAINER\\n   |g")\n";
    $nvidia_cmd;
  fi;
}
